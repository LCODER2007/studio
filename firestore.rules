/**
 * @file Firebase Security Rules for Firestore.
 *
 * @core_philosophy This ruleset prioritizes security and authorization independence. It enforces
 * strict ownership and role-based access control while assuming a flexible data model for rapid prototyping.
 * Read access to `suggestions` is public, while write access is restricted to owners and admins.
 * Data needed for authorization is denormalized onto the documents themselves to avoid costly `get()` calls.
 *
 * @data_structure
 * - `/users/{userId}`: Stores user profiles, including the user's role. The `role` field is
 *   denormalized to avoid extra reads during authorization checks.
 * - `/suggestions/{suggestionId}`: Stores suggestions submitted by users. The `authorUid` field is
 *   used for ownership checks.
 * - `/votes/{voteId}`: Stores votes on suggestions, linking a user to a suggestion.
 * - `/user_votes/{uid}/suggestions/{suggestionId}`: Stores single vote by a user on a suggestion
 * - `/comments/{commentId}`: Stores comments on suggestions.
 *
 * @key_security_decisions
 * - Public read access to the `suggestions` collection to facilitate open consumption.
 * - Owner-only write access to most user-specific data, enforced through `isOwner()` checks.
 * - No user listing is allowed; `list` operations on `/users` are denied.
 * - The `authorUid` field in `suggestions` is used for ownership checks on writes.
 * - Suggestion writes are open but rely on the application to set the `authorUid` correctly.
 *
 * @denormalization_for_authorization
 * - The `role` field is stored directly in the `/users/{userId}` document to avoid extra reads when
 *   checking user roles.
 * - The `authorUid` field is present on `/suggestions/{suggestionId}` documents to enable
 *   ownership checks without additional reads.
 *
 * @structural_segregation
 * - Publicly readable suggestions are stored in the top-level `/suggestions` collection, while
 *   private user data is stored under `/users/{userId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the existing owner of the resource, ensuring the document exists.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user is an admin.
     * @return {bool} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
          return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'ADMIN'
          || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'SUPER_ADMIN';
    }


    /**
     * @description Rules for the /users/{uid} collection.
     * @path /users/{uid}
     * @allow (create) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can create their own user document.
     * @deny (create) User ABC cannot create a document for user XYZ.
     * @allow (get) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can get their own user document.
     * @deny (get) User ABC cannot get user XYZ's document.
     * @allow (update) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can update their own user document.
     * @deny (update) User ABC cannot update user XYZ's document.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // No user listing

      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /suggestions/{suggestionId} collection.
     * @path /suggestions/{suggestionId}
     * @allow (get) Any user can read a suggestion.
     * @allow (list) Any user can list suggestions.
     * @allow (create) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can create a suggestion.
     * @deny (create) User ABC cannot create a suggestion without a valid authorUid.
     * @allow (update) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can update their own suggestion.
     * @deny (update) User ABC cannot update a suggestion they don't own.
     * @principle Allows public reads with owner-only writes, validates relational integrity.
     */
    match /suggestions/{suggestionId} {
      allow get, list: if true; // Public read access

      allow create: if isSignedIn() && request.resource.data.authorUid == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorUid) || isAdmin();
      allow delete: if isExistingOwner(resource.data.authorUid) || isAdmin();
    }

    /**
     * @description Rules for the /votes/{voteId} collection.
     * @path /votes/{voteId}
     * @allow (create) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can create a vote.
     * @deny (create) User ABC cannot create a vote without proper authentication.
     * @allow (get) Any user can read a vote.
     * @deny (get) User ABC cannot read a vote due to insufficient permissions.
     * @allow (update) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can update a vote they own.
     * @deny (update) User ABC cannot update a vote they don't own.
     */
    match /votes/{voteId} {
      allow get, list: if true;

      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

        /**
         * @description Rules for the /user_votes/{uid}/suggestions/{suggestionId} collection.
         * @path /user_votes/{uid}/suggestions/{suggestionId}
         * @allow (create) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can create a vote for a suggestion.
         * @deny (create) User ABC cannot create a vote for a suggestion they don't own.
         * @allow (get) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can get their vote for a suggestion.
         * @deny (get) User ABC cannot get user XYZ's vote.
         * @allow (update) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can update their vote for a suggestion.
         * @deny (update) User ABC cannot update a vote they don't own.
         * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
         */
        match /user_votes/{userId}/suggestions/{suggestionId} {
            allow get: if isOwner(userId);
            allow list: if isOwner(userId);

            allow create: if isOwner(userId);
            allow update: if false;
            allow delete: if isOwner(userId);
        }

    /**
     * @description Rules for the /comments/{commentId} collection.
     * @path /comments/{commentId}
     * @allow (create) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can create a comment.
     * @deny (create) User ABC cannot create a comment without proper authentication.
     * @allow (get) Any user can read a comment.
     * @deny (get) User ABC cannot read a comment due to insufficient permissions.
     * @allow (update) User BC0m0M9PcHMJbYjhsI0HPjriR7x2 can update a comment they own.
     * @deny (update) User ABC cannot update a comment they don't own.
     */
    match /comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorUid) || isAdmin();
      allow delete: if isExistingOwner(resource.data.authorUid) || isAdmin();
    }
  }
}