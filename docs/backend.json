{
  "entities": {
    "Suggestion": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Suggestion",
      "type": "object",
      "description": "Represents a suggestion submitted by a user.",
      "properties": {
        "suggestionId": {
          "type": "string",
          "description": "Unique identifier for the suggestion entity."
        },
        "title": {
          "type": "string",
          "description": "Title of the suggestion.",
          "format": "string"
        },
        "body": {
          "type": "string",
          "description": "Detailed description of the suggestion.",
          "format": "string"
        },
        "authorUid": {
          "type": "string",
          "description": "Reference to the User who created the suggestion. Can also be 'ANONYMOUS'."
        },
        "category": {
          "type": "string",
          "description": "Category of the suggestion (ACADEMIC_CURRICULUM, INFRASTRUCTURE_IT, TECHNICAL_DESIGN, ENVIRONMENTAL_SUSTAINABILITY, ADMINISTRATIVE_SEES, OTHER).",
          "format": "string"
        },
        "status": {
          "type": "string",
          "description": "Status of the suggestion (SUBMITTED, UNDER_REVIEW, SHORTLISTED, ARCHIVED_REJECTED, IMPLEMENTED).",
          "format": "string"
        },
        "upvotesCount": {
          "type": "number",
          "description": "Number of upvotes for the suggestion."
        },
        "impactScore": {
          "type": "number",
          "description": "Impact score of the suggestion (1-5, admin rated)."
        },
        "feasibilityRating": {
          "type": "number",
          "description": "Feasibility rating of the suggestion (1-5, admin rated)."
        },
        "costEffectivenessRating": {
          "type": "number",
          "description": "Cost-effectiveness rating of the suggestion (1-5, admin rated)."
        },
        "reviewerUid": {
          "type": "string",
          "description": "Reference to the User (Admin) who reviewed the suggestion."
        },
        "submissionTimestamp": {
          "type": "string",
          "description": "Timestamp of when the suggestion was submitted.",
          "format": "date-time"
        },
        "publicFeedback": {
          "type": "string",
          "description": "Public feedback on the suggestion."
        }
      },
      "required": [
        "suggestionId",
        "title",
        "body",
        "authorUid",
        "category",
        "status",
        "upvotesCount",
        "submissionTimestamp"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user profile.",
      "properties": {
        "uid": {
          "type": "string",
          "description": "Unique identifier for the user entity."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "displayName": {
          "type": "string",
          "description": "Display name of the user."
        },
        "role": {
          "type": "string",
          "description": "Role of the user (STUDENT, ADMIN, SUPER_ADMIN)."
        }
      },
      "required": [
        "uid",
        "email"
      ]
    },
    "Vote": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Vote",
      "type": "object",
      "description": "Represents a user's vote on a suggestion.",
      "properties": {
        "suggestionId": {
          "type": "string",
          "description": "Reference to the Suggestion being voted on. (Relationship: Suggestion 1:N Vote)"
        },
        "voterUid": {
          "type": "string",
          "description": "Reference to the User who cast the vote. (Relationship: User 1:N Vote)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the vote was cast.",
          "format": "date-time"
        },
        "voteId": {
          "type": "string",
          "description": "Unique identifier for the vote entity."
        }
      },
      "required": [
        "suggestionId",
        "voterUid",
        "timestamp",
        "voteId"
      ]
    },
    "Comment": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Comment",
      "type": "object",
      "description": "Represents a comment on a suggestion.",
      "properties": {
        "commentId": {
          "type": "string",
          "description": "Unique identifier for the comment entity."
        },
        "suggestionId": {
          "type": "string",
          "description": "Reference to the Suggestion the comment belongs to. (Relationship: Suggestion 1:N Comment)"
        },
        "authorUid": {
          "type": "string",
          "description": "Reference to the User who wrote the comment. (Relationship: User 1:N Comment)"
        },
        "body": {
          "type": "string",
          "description": "Content of the comment."
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the comment was posted.",
          "format": "date-time"
        }
      },
      "required": [
        "commentId",
        "suggestionId",
        "authorUid",
        "body",
        "timestamp"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{uid}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information, including the user's role. Used to determine authorization for various actions. Includes denormalized 'role' for authorization independence.",
          "params": [
            {
              "name": "uid",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/suggestions/{suggestionId}",
        "definition": {
          "entityName": "Suggestion",
          "schema": {
            "$ref": "#/backend/entities/Suggestion"
          },
          "description": "Stores suggestions submitted by users. 'authorUid' is used to track the suggestion's author; can be 'ANONYMOUS' for anonymous submissions. Includes fields for admin evaluation (impactScore, feasibilityRating, costEffectivenessRating).",
          "params": [
            {
              "name": "suggestionId",
              "description": "The unique identifier of the suggestion."
            }
          ]
        }
      },
      {
        "path": "/votes/{voteId}",
        "definition": {
          "entityName": "Vote",
          "schema": {
            "$ref": "#/backend/entities/Vote"
          },
          "description": "Stores user votes for suggestions. Enforces one vote per user per suggestion using a composite key of suggestionId and voterUid. This collection triggers the `triggerVoteUpdate` Cloud Function.",
          "params": [
            {
              "name": "voteId",
              "description": "The unique identifier of the vote."
            }
          ]
        }
      },
      {
        "path": "/comments/{commentId}",
        "definition": {
          "entityName": "Comment",
          "schema": {
            "$ref": "#/backend/entities/Comment"
          },
          "description": "Stores comments on suggestions. Each comment is associated with a specific suggestion via the suggestionId field.",
          "params": [
            {
              "name": "commentId",
              "description": "The unique identifier of the comment."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to ensure security, scalability, and debuggability, while adhering to Authorization Independence. The core principle is to avoid hierarchical authorization dependencies by denormalizing data and utilizing structural segregation for homogeneous security postures. The structure incorporates explicit state modeling for clarity and predictable schemas.\n\nAuthorization Independence is achieved by storing the 'role' property directly within the `/users/{uid}` document. This eliminates the need for `get()` calls in security rules to determine user roles. For the suggestions, the `authorUid` field is used, allowing for anonymous submissions via the 'ANONYMOUS' string literal. The `suggestions` documents do not depend on any data outside themselves for authorization decisions.\n\nQAPs (Rules are not Filters) are supported by segregating data based on access needs and using membership models. Read access is granted broadly on `/suggestions` as read access is required by all users, including unauthenticated ones. Write/Update access is limited through security rules based on the user's role which is checked by reading the `/users/{uid}` collection. The use of the `/votes` collection ensures that a user can only vote once per suggestion. Each vote document contains both `suggestionId` and `voterUid`, providing a clear link between the suggestion and the user who voted, which is essential for the `triggerVoteUpdate` Cloud Function.\n\nInvariants are maintained through the enforcement of ownership for user-specific data via path-based rules for the `/users/{uid}` collection. Timestamps are automatically generated and are immutable. Data integrity is also ensured through the custom claims mechanism, which is securely set server-side."
  }
}